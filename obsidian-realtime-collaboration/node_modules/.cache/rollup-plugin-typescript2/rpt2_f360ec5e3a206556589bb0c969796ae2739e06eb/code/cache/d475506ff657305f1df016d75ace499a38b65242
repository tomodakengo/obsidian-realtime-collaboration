{"code":"import * as Y from 'yjs';\nimport { WebrtcProvider } from 'y-webrtc';\nimport { IndexeddbPersistence } from 'y-indexeddb';\nimport { Awareness } from 'y-protocols/awareness';\nexport class YjsManager {\n    doc;\n    providers = new Map();\n    awareness;\n    changeCallbacks = [];\n    connectionCallbacks = [];\n    isDestroyed = false;\n    constructor(documentId, options = {}) {\n        const inBrowser = typeof window !== 'undefined' && typeof document !== 'undefined';\n        const hasIndexedDB = typeof indexedDB !== 'undefined';\n        const canWebrtc = inBrowser && typeof globalThis.RTCPeerConnection !== 'undefined';\n        this.doc = options.doc ?? new Y.Doc();\n        this.awareness = new Awareness(this.doc);\n        const shouldIndexeddb = options.enableIndexeddb ?? (inBrowser && hasIndexedDB);\n        const shouldWebrtc = options.enableWebrtc ?? canWebrtc;\n        // Set up awareness\n        this.setupAwareness();\n        // Set up providers\n        if (shouldIndexeddb) {\n            this.setupIndexedDB(documentId);\n        }\n        if (shouldWebrtc) {\n            this.setupWebRTC(documentId, options);\n        }\n        // Set up document observers\n        this.setupDocumentObservers();\n    }\n    setupAwareness() {\n        // Set local user state\n        this.awareness.setLocalState({\n            user: {\n                id: this.generateUserId(),\n                name: 'Anonymous User',\n                color: this.generateUserColor(),\n                status: 'online'\n            },\n            lastSeen: Date.now()\n        });\n        // Listen for awareness changes\n        this.awareness.on('change', (changes) => {\n            console.log('Awareness changed:', changes);\n        });\n    }\n    setupIndexedDB(documentId) {\n        try {\n            const yIndexeddb = new IndexeddbPersistence(documentId, this.doc);\n            yIndexeddb.once('synced', () => {\n                console.log('IndexedDB synced for document:', documentId);\n            });\n            this.providers.set('indexeddb', yIndexeddb);\n        }\n        catch (error) {\n            console.warn('Failed to initialize IndexedDB persistence:', error);\n        }\n    }\n    setupWebRTC(documentId, options) {\n        try {\n            const roomName = options.roomName || documentId;\n            const signalingServers = options.signalingServers || [\n                'wss://signaling.yjs.dev',\n                'wss://y-webrtc-signaling-eu.herokuapp.com',\n                'wss://y-webrtc-signaling-us.herokuapp.com'\n            ];\n            const webrtc = new WebrtcProvider(roomName, this.doc, {\n                signaling: signalingServers,\n                password: options.password,\n                awareness: this.awareness,\n                maxConns: 20,\n                filterBcConns: false,\n                peerOpts: {}\n            });\n            // Set up WebRTC event listeners\n            webrtc.on('status', ({ connected }) => {\n                console.log('WebRTC connection status:', connected ? 'connected' : 'disconnected');\n                this.notifyConnectionChange(connected);\n            });\n            webrtc.on('synced', () => {\n                console.log('WebRTC synced');\n            });\n            webrtc.on('peers', (peers) => {\n                console.log('WebRTC peers:', peers);\n            });\n            this.providers.set('webrtc', webrtc);\n        }\n        catch (error) {\n            console.warn('Failed to initialize WebRTC provider:', error);\n        }\n    }\n    setupDocumentObservers() {\n        // Observe all text elements in the document\n        this.doc.on('afterTransaction', (transaction) => {\n            if (transaction.local)\n                return;\n            // Process changes from the transaction\n            transaction.changed.forEach((changeSet, parent) => {\n                if (parent instanceof Y.Text) {\n                    this.processTextChanges(parent, changeSet, transaction);\n                }\n            });\n        });\n    }\n    processTextChanges(text, changeSet, transaction) {\n        // Get the changes from the transaction\n        const changes = changeSet.delta;\n        changes.forEach((change) => {\n            if (change.insert) {\n                // Text was inserted\n                this.notifyChange({\n                    type: 'insert',\n                    position: changeSet.anchor,\n                    length: change.insert.length,\n                    content: change.insert,\n                    timestamp: Date.now(),\n                    userId: this.getUserIdFromTransaction(transaction)\n                });\n            }\n            else if (change.delete) {\n                // Text was deleted\n                this.notifyChange({\n                    type: 'delete',\n                    position: changeSet.anchor,\n                    length: change.delete,\n                    timestamp: Date.now(),\n                    userId: this.getUserIdFromTransaction(transaction)\n                });\n            }\n        });\n    }\n    getUserIdFromTransaction(transaction) {\n        // Try to get user ID from awareness\n        const origin = transaction.origin;\n        if (origin && typeof origin === 'object' && 'userId' in origin) {\n            return origin.userId;\n        }\n        return undefined;\n    }\n    getText(name = 'content') {\n        return this.doc.getText(name);\n    }\n    getDoc() {\n        return this.doc;\n    }\n    getAwareness() {\n        return this.awareness;\n    }\n    getConnectedUsers() {\n        return this.awareness.getStates();\n    }\n    getLocalUserState() {\n        return this.awareness.getLocalState();\n    }\n    setLocalUserState(state) {\n        this.awareness.setLocalState(state);\n    }\n    isConnected() {\n        const webrtcProvider = this.providers.get('webrtc');\n        return webrtcProvider ? webrtcProvider.connected : false;\n    }\n    connect() {\n        const webrtcProvider = this.providers.get('webrtc');\n        if (webrtcProvider && typeof webrtcProvider.connect === 'function') {\n            webrtcProvider.connect();\n        }\n    }\n    disconnect() {\n        const webrtcProvider = this.providers.get('webrtc');\n        if (webrtcProvider && typeof webrtcProvider.disconnect === 'function') {\n            webrtcProvider.disconnect();\n        }\n    }\n    onDocumentChange(callback) {\n        this.changeCallbacks.push(callback);\n    }\n    offDocumentChange(callback) {\n        const index = this.changeCallbacks.indexOf(callback);\n        if (index > -1) {\n            this.changeCallbacks.splice(index, 1);\n        }\n    }\n    onConnectionChange(callback) {\n        this.connectionCallbacks.push(callback);\n    }\n    offConnectionChange(callback) {\n        const index = this.connectionCallbacks.indexOf(callback);\n        if (index > -1) {\n            this.connectionCallbacks.splice(index, 1);\n        }\n    }\n    notifyChange(event) {\n        this.changeCallbacks.forEach(callback => {\n            try {\n                callback(event);\n            }\n            catch (error) {\n                console.error('Error in document change callback:', error);\n            }\n        });\n    }\n    notifyConnectionChange(connected) {\n        this.connectionCallbacks.forEach(callback => {\n            try {\n                callback(connected);\n            }\n            catch (error) {\n                console.error('Error in connection change callback:', error);\n            }\n        });\n    }\n    generateUserId() {\n        return 'user_' + Math.random().toString(36).substr(2, 9);\n    }\n    generateUserColor() {\n        const colors = [\n            '#007acc', '#ff6b6b', '#4ecdc4', '#45b7d1', '#96ceb4',\n            '#feca57', '#ff9ff3', '#54a0ff', '#5f27cd', '#00d2d3'\n        ];\n        return colors[Math.floor(Math.random() * colors.length)];\n    }\n    destroy() {\n        if (this.isDestroyed)\n            return;\n        this.isDestroyed = true;\n        // Clean up providers\n        this.providers.forEach((provider) => {\n            try {\n                if (provider && typeof provider.destroy === 'function') {\n                    provider.destroy();\n                }\n            }\n            catch (error) {\n                console.warn('Error destroying provider:', error);\n            }\n        });\n        this.providers.clear();\n        // Clean up awareness\n        try {\n            this.awareness.destroy();\n        }\n        catch (error) {\n            console.warn('Error destroying awareness:', error);\n        }\n        // Clean up document\n        try {\n            this.doc.destroy();\n        }\n        catch (error) {\n            console.warn('Error destroying document:', error);\n        }\n        // Clear callbacks\n        this.changeCallbacks.length = 0;\n        this.connectionCallbacks.length = 0;\n    }\n}\n","references":["/workspace/obsidian-realtime-collaboration/node_modules/yjs/dist/src/index.d.ts","/workspace/obsidian-realtime-collaboration/node_modules/y-webrtc/dist/src/y-webrtc.d.ts","/workspace/obsidian-realtime-collaboration/node_modules/y-indexeddb/dist/src/y-indexeddb.d.ts","/workspace/obsidian-realtime-collaboration/node_modules/y-protocols/awareness.d.ts"]}
