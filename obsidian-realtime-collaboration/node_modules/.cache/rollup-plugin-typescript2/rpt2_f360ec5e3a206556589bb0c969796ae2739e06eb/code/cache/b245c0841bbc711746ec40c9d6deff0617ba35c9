{"code":"export class ObsidianEditorBinding {\n    ytext;\n    editor;\n    isUpdating = false;\n    lastAppliedLength = 0;\n    constructor(ytext, editor) {\n        this.ytext = ytext;\n        this.editor = editor;\n        this.setupBindings();\n        this.syncInitialContent();\n    }\n    setupBindings() {\n        // Y.js → Editor binding\n        this.ytext.observe((event) => {\n            // Check if this is a remote change (not local)\n            if (!event.transaction?.local && !this.isUpdating) {\n                this.isUpdating = true;\n                try {\n                    // Apply remote changes to editor\n                    this.applyRemoteChangesToEditor(event);\n                }\n                finally {\n                    this.isUpdating = false;\n                }\n            }\n        });\n        // Editor → Y.js binding\n        this.editor.on('changes', (changes) => {\n            if (!this.isUpdating) {\n                this.isUpdating = true;\n                try {\n                    // Apply editor changes to Y.js\n                    this.applyEditorChangesToYjs(changes);\n                }\n                finally {\n                    this.isUpdating = false;\n                }\n            }\n        });\n    }\n    syncInitialContent() {\n        // Sync initial content from Y.js to editor\n        const yjsContent = this.ytext.toString();\n        const editorContent = this.editor.getValue();\n        if (yjsContent !== editorContent) {\n            if (yjsContent.length > 0) {\n                // Y.js has content, sync to editor\n                this.editor.setValue(yjsContent);\n            }\n            else if (editorContent.length > 0) {\n                // Editor has content, sync to Y.js\n                this.ytext.delete(0, this.ytext.length);\n                this.ytext.insert(0, editorContent);\n            }\n        }\n        this.lastAppliedLength = this.ytext.length;\n    }\n    applyRemoteChangesToEditor(event) {\n        try {\n            // Get the current Y.js content\n            const yjsContent = this.ytext.toString();\n            const editorContent = this.editor.getValue();\n            // Only update if content actually changed\n            if (yjsContent !== editorContent) {\n                this.editor.setValue(yjsContent);\n                this.lastAppliedLength = yjsContent.length;\n                console.log('Applied remote changes to editor:', yjsContent.length, 'characters');\n            }\n        }\n        catch (error) {\n            console.error('Error applying remote changes to editor:', error);\n        }\n    }\n    applyEditorChangesToYjs(changes) {\n        try {\n            const editorContent = this.editor.getValue();\n            const yjsContent = this.ytext.toString();\n            // Only update if content actually changed\n            if (editorContent !== yjsContent) {\n                // Calculate the difference and apply it to Y.js\n                this.applyTextChanges(editorContent, yjsContent);\n                this.lastAppliedLength = editorContent.length;\n                console.log('Applied editor changes to Y.js:', editorContent.length, 'characters');\n            }\n        }\n        catch (error) {\n            console.error('Error applying editor changes to Y.js:', error);\n        }\n    }\n    applyTextChanges(newContent, oldContent) {\n        // Simple diff algorithm for text changes\n        const minLength = Math.min(newContent.length, oldContent.length);\n        let commonPrefix = 0;\n        // Find common prefix\n        while (commonPrefix < minLength && newContent[commonPrefix] === oldContent[commonPrefix]) {\n            commonPrefix++;\n        }\n        // Find common suffix\n        let commonSuffix = 0;\n        while (commonSuffix < minLength - commonPrefix &&\n            newContent[newContent.length - 1 - commonSuffix] === oldContent[oldContent.length - 1 - commonSuffix]) {\n            commonSuffix++;\n        }\n        // Apply changes\n        const startPos = commonPrefix;\n        const endPos = oldContent.length - commonSuffix;\n        const newText = newContent.substring(commonPrefix, newContent.length - commonSuffix);\n        if (endPos > startPos) {\n            this.ytext.delete(startPos, endPos);\n        }\n        if (newText.length > 0) {\n            this.ytext.insert(startPos, newText);\n        }\n    }\n    getYjsText() {\n        return this.ytext;\n    }\n    getEditor() {\n        return this.editor;\n    }\n    isUpdatingContent() {\n        return this.isUpdating;\n    }\n    destroy() {\n        // Cleanup observers and event listeners\n        this.isUpdating = true;\n    }\n}\n// Simple editor binding factory\nexport function createSimpleEditorBinding(ytext, editor) {\n    return new ObsidianEditorBinding(ytext, editor);\n}\n// Placeholder for CodeMirror integration (to be implemented later)\nexport function createCollaborativeViewPlugin(ytext) {\n    // This will be implemented when CodeMirror integration is needed\n    console.log('CodeMirror integration not yet implemented');\n    return null;\n}\n","references":["/workspace/obsidian-realtime-collaboration/node_modules/yjs/dist/src/index.d.ts"]}
