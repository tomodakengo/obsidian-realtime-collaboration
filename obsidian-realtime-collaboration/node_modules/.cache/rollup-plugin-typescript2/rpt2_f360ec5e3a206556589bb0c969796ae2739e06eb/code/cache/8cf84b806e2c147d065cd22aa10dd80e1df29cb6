{"code":"export class UserAwareness {\n    users = new Map();\n    userActivities = new Map();\n    userChangeCallbacks = [];\n    maxUsers;\n    userTimeout;\n    cleanupTimers = new Map();\n    constructor(options = {}) {\n        this.maxUsers = options.maxUsers || 100;\n        this.userTimeout = options.userTimeout || 30000; // 30 seconds\n    }\n    addUser(user) {\n        if (this.users.size >= this.maxUsers) {\n            console.warn(`Maximum number of users (${this.maxUsers}) reached`);\n            return;\n        }\n        // Clear existing timeout if user already exists\n        if (this.cleanupTimers.has(user.id)) {\n            clearTimeout(this.cleanupTimers.get(user.id));\n            this.cleanupTimers.delete(user.id);\n        }\n        this.users.set(user.id, user);\n        this.userActivities.set(user.id, []);\n        this.notifyUserChange();\n        // Set timeout to automatically remove inactive users\n        if (this.userTimeout > 0) {\n            const timer = setTimeout(() => {\n                this.removeUser(user.id);\n            }, this.userTimeout);\n            this.cleanupTimers.set(user.id, timer);\n        }\n    }\n    removeUser(userId) {\n        if (this.users.has(userId)) {\n            this.users.delete(userId);\n            this.userActivities.delete(userId);\n            // Clear cleanup timer\n            if (this.cleanupTimers.has(userId)) {\n                clearTimeout(this.cleanupTimers.get(userId));\n                this.cleanupTimers.delete(userId);\n            }\n            this.notifyUserChange();\n        }\n    }\n    updateUser(user) {\n        if (this.users.has(user.id)) {\n            this.users.set(user.id, user);\n            this.notifyUserChange();\n        }\n    }\n    updateUserActivity(userId, activity) {\n        if (!this.users.has(userId))\n            return;\n        const activities = this.userActivities.get(userId) || [];\n        activities.push(activity);\n        // Keep only the last 100 activities per user\n        if (activities.length > 100) {\n            activities.splice(0, activities.length - 100);\n        }\n        this.userActivities.set(userId, activities);\n        // Refresh user timeout\n        this.refreshUser(userId);\n    }\n    getUserActivity(userId) {\n        return this.userActivities.get(userId) || [];\n    }\n    getRecentUserActivity(userId, minutes = 5) {\n        const activities = this.getUserActivity(userId);\n        const cutoffTime = Date.now() - (minutes * 60 * 1000);\n        return activities.filter(activity => activity.timestamp > cutoffTime);\n    }\n    getUser(userId) {\n        return this.users.get(userId);\n    }\n    getUsers() {\n        return Array.from(this.users.values());\n    }\n    getUserCount() {\n        return this.users.size;\n    }\n    hasUser(userId) {\n        return this.users.has(userId);\n    }\n    clearUsers() {\n        // Clear all cleanup timers\n        this.cleanupTimers.forEach(timer => clearTimeout(timer));\n        this.cleanupTimers.clear();\n        this.users.clear();\n        this.userActivities.clear();\n        this.notifyUserChange();\n    }\n    onUsersChange(callback) {\n        this.userChangeCallbacks.push(callback);\n    }\n    offUsersChange(callback) {\n        const index = this.userChangeCallbacks.indexOf(callback);\n        if (index > -1) {\n            this.userChangeCallbacks.splice(index, 1);\n        }\n    }\n    notifyUserChange() {\n        const users = this.getUsers();\n        this.userChangeCallbacks.forEach(callback => {\n            try {\n                callback(users);\n            }\n            catch (error) {\n                console.error('Error in user change callback:', error);\n            }\n        });\n    }\n    refreshUser(userId) {\n        const user = this.users.get(userId);\n        if (user) {\n            // Reset the timeout for this user\n            if (this.cleanupTimers.has(userId)) {\n                clearTimeout(this.cleanupTimers.get(userId));\n            }\n            if (this.userTimeout > 0) {\n                const timer = setTimeout(() => {\n                    this.removeUser(userId);\n                }, this.userTimeout);\n                this.cleanupTimers.set(userId, timer);\n            }\n        }\n    }\n    getOnlineUsers() {\n        return this.getUsers().filter(user => user.status === 'online');\n    }\n    getAwayUsers() {\n        return this.getUsers().filter(user => user.status === 'away');\n    }\n    getOfflineUsers() {\n        return this.getUsers().filter(user => user.status === 'offline');\n    }\n    setUserStatus(userId, status) {\n        const user = this.users.get(userId);\n        if (user) {\n            user.status = status;\n            this.notifyUserChange();\n        }\n    }\n    setUserColor(userId, color) {\n        const user = this.users.get(userId);\n        if (user) {\n            user.color = color;\n            this.notifyUserChange();\n        }\n    }\n    setUserName(userId, name) {\n        const user = this.users.get(userId);\n        if (user) {\n            user.name = name;\n            this.notifyUserChange();\n        }\n    }\n    destroy() {\n        // Clear all cleanup timers\n        this.cleanupTimers.forEach(timer => clearTimeout(timer));\n        this.cleanupTimers.clear();\n        this.users.clear();\n        this.userActivities.clear();\n        this.userChangeCallbacks = [];\n    }\n}\n","references":["/workspace/obsidian-realtime-collaboration/src/types/index.ts"]}
