{"code":"export class EncryptionManager {\n    toArrayBuffer(data) {\n        const view = data instanceof ArrayBuffer\n            ? new Uint8Array(data)\n            : new Uint8Array(data.buffer, data.byteOffset, data.byteLength);\n        const out = new ArrayBuffer(view.byteLength);\n        new Uint8Array(out).set(view);\n        return out;\n    }\n    async encryptUpdate(update, key) {\n        const iv = crypto.getRandomValues(new Uint8Array(12));\n        const encrypted = await crypto.subtle.encrypt({ name: 'AES-GCM', iv }, key, this.toArrayBuffer(update));\n        return new Uint8Array([...iv, ...new Uint8Array(encrypted)]);\n    }\n    async decryptUpdate(encryptedData, key) {\n        try {\n            // Extract IV (first 12 bytes) and encrypted data\n            const iv = encryptedData.slice(0, 12);\n            const encrypted = encryptedData.slice(12);\n            const decrypted = await crypto.subtle.decrypt({ name: 'AES-GCM', iv }, key, encrypted);\n            return new Uint8Array(decrypted);\n        }\n        catch (error) {\n            console.error('Decryption failed:', error);\n            throw new Error('Failed to decrypt data');\n        }\n    }\n    async generateRoomKey(password, salt) {\n        const keyMaterial = await crypto.subtle.importKey('raw', new TextEncoder().encode(password), 'PBKDF2', false, ['deriveKey']);\n        return crypto.subtle.deriveKey({ name: 'PBKDF2', salt: this.toArrayBuffer(salt), iterations: 100000, hash: 'SHA-256' }, keyMaterial, { name: 'AES-GCM', length: 256 }, false, ['encrypt', 'decrypt']);\n    }\n    async generateRandomKey() {\n        return crypto.subtle.generateKey({ name: 'AES-GCM', length: 256 }, true, ['encrypt', 'decrypt']);\n    }\n    async generateRandomSalt() {\n        return crypto.getRandomValues(new Uint8Array(16));\n    }\n    async hashPassword(password, salt) {\n        const encoder = new TextEncoder();\n        const data = encoder.encode(password);\n        const hashBuffer = await crypto.subtle.digest('SHA-256', data);\n        const hashArray = Array.from(new Uint8Array(hashBuffer));\n        const hashHex = hashArray.map(b => b.toString(16).padStart(2, '0')).join('');\n        return hashHex;\n    }\n    async verifyPassword(password, salt, expectedHash) {\n        const actualHash = await this.hashPassword(password, salt);\n        return actualHash === expectedHash;\n    }\n    async encryptText(text, key) {\n        const encoder = new TextEncoder();\n        const data = encoder.encode(text);\n        const encrypted = await this.encryptUpdate(data, key);\n        return btoa(String.fromCharCode(...encrypted));\n    }\n    async decryptText(encryptedText, key) {\n        try {\n            const encrypted = Uint8Array.from(atob(encryptedText), c => c.charCodeAt(0));\n            const decrypted = await this.decryptUpdate(encrypted, key);\n            const decoder = new TextDecoder();\n            return decoder.decode(decrypted);\n        }\n        catch (error) {\n            console.error('Text decryption failed:', error);\n            throw new Error('Failed to decrypt text');\n        }\n    }\n    async generateKeyPair() {\n        return crypto.subtle.generateKey({\n            name: 'RSA-OAEP',\n            modulusLength: 2048,\n            publicExponent: new Uint8Array([1, 0, 1]),\n            hash: 'SHA-256'\n        }, true, ['encrypt', 'decrypt']);\n    }\n    async encryptWithPublicKey(data, publicKey) {\n        return crypto.subtle.encrypt({ name: 'RSA-OAEP' }, publicKey, data);\n    }\n    async decryptWithPrivateKey(encryptedData, privateKey) {\n        return crypto.subtle.decrypt({ name: 'RSA-OAEP' }, privateKey, encryptedData);\n    }\n    async signData(data, privateKey) {\n        return crypto.subtle.sign({ name: 'RSA-PSS', saltLength: 32 }, privateKey, data);\n    }\n    async verifySignature(data, signature, publicKey) {\n        return crypto.subtle.verify({ name: 'RSA-PSS', saltLength: 32 }, publicKey, signature, data);\n    }\n}\n","references":[]}
