{"code":"import { WebrtcProvider } from 'y-webrtc';\nimport { ConnectionState } from '../types';\nexport class P2PProvider {\n    roomName;\n    doc;\n    signalingServers;\n    password;\n    awareness;\n    provider;\n    connectionState = ConnectionState.DISCONNECTED;\n    connectionChangeCallbacks = [];\n    constructor(roomName, doc, options = {}) {\n        this.roomName = roomName;\n        this.doc = doc;\n        this.signalingServers = options.signalingServers || [\n            'wss://signaling.yjs.dev',\n            'wss://y-webrtc-signaling-eu.herokuapp.com',\n            'wss://y-webrtc-signaling-us.herokuapp.com'\n        ];\n        this.password = options.password;\n        this.awareness = options.awareness;\n        this.initializeProvider();\n    }\n    initializeProvider() {\n        try {\n            // Check if WebRTC is available\n            if (typeof window !== 'undefined' && typeof globalThis.RTCPeerConnection !== 'undefined') {\n                this.provider = new WebrtcProvider(this.roomName, this.doc, {\n                    signaling: this.signalingServers,\n                    password: this.password,\n                    awareness: this.awareness,\n                    maxConns: 20,\n                    filterBcConns: false,\n                    peerOpts: {}\n                });\n                this.setupEventListeners();\n                this.connectionState = ConnectionState.DISCONNECTED;\n            }\n            else {\n                console.warn('WebRTC not available, P2P provider will not be initialized');\n            }\n        }\n        catch (error) {\n            console.error('Failed to initialize P2P provider:', error);\n            this.connectionState = ConnectionState.ERROR;\n        }\n    }\n    setupEventListeners() {\n        if (!this.provider)\n            return;\n        this.provider.on('status', ({ connected }) => {\n            switch (connected ? 'connected' : 'disconnected') {\n                case 'connected':\n                    this.connectionState = ConnectionState.CONNECTED;\n                    break;\n                case 'disconnected':\n                    this.connectionState = ConnectionState.DISCONNECTED;\n                    break;\n                default:\n                    this.connectionState = ConnectionState.ERROR;\n            }\n            this.notifyConnectionChange();\n        });\n        this.provider.on('synced', () => {\n            console.log('WebRTC synced');\n        });\n        this.provider.on('peers', (peers) => {\n            console.log('WebRTC peers:', peers);\n        });\n    }\n    connect() {\n        if (this.provider && this.connectionState === ConnectionState.DISCONNECTED) {\n            this.connectionState = ConnectionState.CONNECTING;\n            this.notifyConnectionChange();\n            // The provider will automatically attempt to connect\n            // The status event will update the connection state\n        }\n    }\n    disconnect() {\n        if (this.provider && this.connectionState === ConnectionState.CONNECTED) {\n            this.provider.disconnect();\n            this.connectionState = ConnectionState.DISCONNECTED;\n            this.notifyConnectionChange();\n        }\n    }\n    destroy() {\n        if (this.provider) {\n            this.provider.destroy();\n            this.provider = undefined;\n        }\n        this.connectionState = ConnectionState.DISCONNECTED;\n        this.connectionChangeCallbacks = [];\n    }\n    getConnectionState() {\n        return this.connectionState;\n    }\n    onConnectionChange(callback) {\n        this.connectionChangeCallbacks.push(callback);\n    }\n    offConnectionChange(callback) {\n        const index = this.connectionChangeCallbacks.indexOf(callback);\n        if (index > -1) {\n            this.connectionChangeCallbacks.splice(index, 1);\n        }\n    }\n    notifyConnectionChange() {\n        this.connectionChangeCallbacks.forEach(callback => {\n            try {\n                callback(this.connectionState);\n            }\n            catch (error) {\n                console.error('Error in connection change callback:', error);\n            }\n        });\n    }\n    getLocalUserState() {\n        if (this.provider?.awareness) {\n            return this.provider.awareness.getLocalState();\n        }\n        return null;\n    }\n    getConnectedPeers() {\n        if (this.provider?.awareness) {\n            return Array.from(this.provider.awareness.getStates().keys());\n        }\n        return [];\n    }\n    isConnected() {\n        return this.connectionState === ConnectionState.CONNECTED;\n    }\n    getRoomName() {\n        return this.roomName;\n    }\n    getProvider() {\n        return this.provider;\n    }\n}\n","references":["/workspace/obsidian-realtime-collaboration/node_modules/yjs/dist/src/index.d.ts","/workspace/obsidian-realtime-collaboration/node_modules/y-webrtc/dist/src/y-webrtc.d.ts","/workspace/obsidian-realtime-collaboration/src/types/index.ts"]}
