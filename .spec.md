# Obsidian協同編集プラグイン実装ガイド

リアルタイム協同編集機能をObsidianプラグインで実装する包括的な調査により、**Y.js + WebRTC P2Pアプローチが最適解**であることが判明しました。この手法により月額5-20ドルという低コストで、Google Docsレベルの協同編集機能を実現できます。

## 推奨技術スタック

研究の結果、以下の技術組み合わせが**コスト効率と技術的優位性**の両面で最適であることが確認されました。**Y.js**は週間900,000ダウンロードを誇る成熟したCRDTライブラリで、NotionやProton Docsなどの主要アプリケーションで採用されています。

**コア技術スタック**:
- **Y.js**: CRDT（Conflict-free Replicated Data Types）による自動競合解決
- **WebRTC (y-webrtc)**: P2P通信による直接同期（サーバーコスト最小化）
- **IndexedDB (y-indexeddb)**: ローカル永続化
- **TypeScript**: 型安全性を保った開発

**コスト効率分析**では、1-20ユーザーの場合は純粋P2Pで月額5-10ドル、20-100ユーザーでハイブリッドP2P+Firebaseで月額15-30ドルという結果が得られました。

## Obsidianプラグイン基本構造

### プロジェクトディレクトリ構成
```
obsidian-collaborative-plugin/
├── main.ts                 # プラグインエントリーポイント
├── manifest.json           # プラグインメタデータ
├── package.json            # 依存関係
├── tsconfig.json           # TypeScript設定
├── rollup.config.js        # ビルド設定
├── src/
│   ├── collaborative/      # 協同編集コアロジック
│   │   ├── YjsManager.ts   # Y.js文書管理
│   │   ├── P2PProvider.ts  # WebRTC P2P通信
│   │   └── EditorBinding.ts # Obsidianエディター統合
│   ├── ui/                 # UI コンポーネント
│   │   ├── UserAwareness.ts # ユーザー存在表示
│   │   └── ShareDialog.ts  # 共有ダイアログ
│   ├── security/           # セキュリティ層
│   │   ├── Encryption.ts   # E2E暗号化
│   │   └── AccessControl.ts # アクセス制御
│   └── types/              # 型定義
└── styles.css              # UI スタイル
```

### 必須設定ファイル

**manifest.json**:
```json
{
    "id": "collaborative-editor",
    "name": "Collaborative Editor",
    "version": "1.0.0",
    "minAppVersion": "0.15.0",
    "description": "Real-time collaborative editing for Obsidian",
    "author": "Your Name",
    "isDesktopOnly": false
}
```

**tsconfig.json**:
```json
{
    "compilerOptions": {
        "target": "ESNext",
        "module": "NodeNext",
        "lib": ["DOM", "ESNext"],
        "allowJs": true,
        "allowSyntheticDefaultImports": true,
        "inlineSourceMap": true,
        "noImplicitAny": true,
        "types": ["node", "obsidian-typings"]
    }
}
```

## 協同編集技術実装詳細

### Y.jsによるCRDT実装

**CRDT（Conflict-free Replicated Data Types）**は数学的に競合のない分散データ型で、従来のOperational Transform（OT）より優れた特性を持ちます。Y.jsは**YATA（Yet Another Transformation Approach）アルゴリズム**の最適化実装で、以下の利点があります：

**技術的優位性**:
- **自動競合解決**: 数学的保証による最終一貫性
- **P2P対応**: サーバー不要の真の分散アーキテクチャ
- **高性能**: 100万操作でも220MB RAM使用量に抑制
- **リアルタイム性**: ローカル操作は即座に適用

**コア実装パターン**:
```typescript
import * as Y from 'yjs'
import { WebrtcProvider } from 'y-webrtc'
import { IndexeddbPersistence } from 'y-indexeddb'

export class CollaborativeDocument {
    private doc: Y.Doc
    private provider: WebrtcProvider
    private persistence: IndexeddbPersistence
    private ytext: Y.Text
    
    constructor(documentId: string, roomName: string) {
        this.doc = new Y.Doc()
        this.ytext = this.doc.getText('content')
        
        // ローカル永続化
        this.persistence = new IndexeddbPersistence(documentId, this.doc)
        
        // P2P通信プロバイダー
        this.provider = new WebrtcProvider(roomName, this.doc)
        
        // 変更監視
        this.setupObservers()
    }
    
    private setupObservers() {
        this.ytext.observe((event) => {
            if (!event.transaction.local) {
                // リモート変更をObsidianエディターに適用
                this.applyToObsidianEditor(event.changes.delta)
            }
        })
    }
}
```

### Obsidianエディター統合

ObsidianはCodeMirror 6を使用しており、**ViewPlugin**を通じて協同編集機能を統合します：

```typescript
import { ViewPlugin, EditorView, ViewUpdate } from "@codemirror/view"
import { Plugin } from "obsidian"

export class ObsidianCollaborativePlugin extends Plugin {
    async onload() {
        // エディター拡張を登録
        this.registerEditorExtension(this.createCollaborativeExtension())
    }
    
    private createCollaborativeExtension() {
        return ViewPlugin.fromClass(class {
            constructor(view: EditorView) {
                // Y.js文書との双方向バインディング
                this.bindToYjs(view)
            }
            
            update(update: ViewUpdate) {
                if (update.docChanged) {
                    // Obsidianの変更をY.jsに伝播
                    this.propagateToYjs(update.changes)
                }
            }
        })
    }
}
```

## コスト最適化インフラ戦略

### WebRTC P2Pアプローチの経済性

**WebRTC P2P実装**が最もコスト効率的であることが判明しました。実際のコスト分析：

**小規模チーム（1-20ユーザー）**:
- P2P同期: **$0/月**（データ転送コストなし）
- シグナリングサーバー: **$5-10/月**（VPS または Railway）
- **ユーザー当たり月額: $0.25-0.50**

**中規模チーム（20-100ユーザー）**:
- ハイブリッドP2P + Firebaseコーディネーション: **$15-30/月**
- **ユーザー当たり月額: $0.15-0.30**

### ハイブリッドアーキテクチャ実装

**3層アーキテクチャ**を推奨します：

**Layer 1: WebRTC P2P**
```typescript
// 直接P2P通信（コストゼロ）
const webrtcProvider = new WebrtcProvider(roomName, doc, {
    signaling: ['ws://your-signaling-server.com']
})
```

**Layer 2: コーディネーションサーバー**
```typescript
// ユーザー存在管理とルーム管理
const coordinationProvider = new WebsocketProvider(
    'ws://coordination-server.com',
    roomName,
    doc,
    { connect: false } // P2P失敗時のフォールバック
)
```

**Layer 3: 永続化**
```typescript
// Firebase Realtime Database（無料枠活用）
const firebaseProvider = new FirebaseProvider(roomName, doc, {
    maxConnections: 100 // 無料枠制限
})
```

### インフラコスト比較

研究により以下の**コストブレイクダウン**が明らかになりました：

| ソリューション | 月額コスト | 適用ユーザー数 | 備考 |
|---------------|------------|----------------|------|
| 純粋P2P | $5-10 | 1-30 | シグナリングサーバーのみ |
| ハイブリッドP2P | $15-30 | 30-100 | Firebase調整 + VPS |
| Firebase主体 | $50-100 | 100-500 | 運用コスト削減 |
| カスタムサーバー | $100-500 | 500+ | フルコントロール |

## セキュリティとプライバシー実装

### エンドツーエンド暗号化

**ゼロノレッジアーキテクチャ**を実装し、サーバーが平文データにアクセスできない仕組みを構築：

```typescript
export class EncryptionManager {
    private async encryptUpdate(update: Uint8Array, key: CryptoKey): Promise<Uint8Array> {
        const iv = crypto.getRandomValues(new Uint8Array(12))
        const encrypted = await crypto.subtle.encrypt(
            { name: 'AES-GCM', iv },
            key,
            update
        )
        return new Uint8Array([...iv, ...new Uint8Array(encrypted)])
    }
    
    private async generateRoomKey(password: string, salt: Uint8Array): Promise<CryptoKey> {
        const keyMaterial = await crypto.subtle.importKey(
            'raw',
            new TextEncoder().encode(password),
            'PBKDF2',
            false,
            ['deriveKey']
        )
        
        return crypto.subtle.deriveKey(
            { name: 'PBKDF2', salt, iterations: 100000, hash: 'SHA-256' },
            keyMaterial,
            { name: 'AES-GCM', length: 256 },
            false,
            ['encrypt', 'decrypt']
        )
    }
}
```

### アクセス制御パターン

**SharedFolder概念**を実装し、ID/パスワードベースのアクセス制御を提供：

```typescript
interface SharedFolder {
    id: string
    name: string
    passwordHash: string
    participants: Set<string>
    permissions: Map<string, Permission[]>
}

enum Permission {
    READ = 'read',
    WRITE = 'write',
    SHARE = 'share',
    ADMIN = 'admin'
}
```

## 主要コンポーネント設計

### YjsManager（文書管理コア）

```typescript
export class YjsManager {
    private doc: Y.Doc
    private providers: Map<string, Provider> = new Map()
    private awareness: Awareness
    
    constructor(documentId: string) {
        this.doc = new Y.Doc()
        this.awareness = new awarenessProtocol.Awareness(this.doc)
        this.setupProviders(documentId)
    }
    
    private setupProviders(documentId: string) {
        // 複数プロバイダーで冗長性確保
        const webrtc = new WebrtcProvider(documentId, this.doc)
        const websocket = new WebsocketProvider('ws://backup-server.com', documentId, this.doc)
        const indexeddb = new IndexeddbPersistence(documentId, this.doc)
        
        this.providers.set('webrtc', webrtc)
        this.providers.set('websocket', websocket)
        this.providers.set('indexeddb', indexeddb)
    }
    
    public getText(name: string = 'content'): Y.Text {
        return this.doc.getText(name)
    }
    
    public destroy() {
        this.providers.forEach(provider => provider.destroy())
        this.doc.destroy()
    }
}
```

### EditorBinding（エディター統合）

```typescript
export class ObsidianEditorBinding {
    private ytext: Y.Text
    private editor: Editor
    private isUpdating = false
    
    constructor(ytext: Y.Text, editor: Editor) {
        this.ytext = ytext
        this.editor = editor
        this.setupBindings()
    }
    
    private setupBindings() {
        // Y.js → Obsidian
        this.ytext.observe((event) => {
            if (!event.transaction.local && !this.isUpdating) {
                this.isUpdating = true
                this.applyChangesToEditor(event.changes.delta)
                this.isUpdating = false
            }
        })
        
        // Obsidian → Y.js
        this.editor.on('changes', (changes) => {
            if (!this.isUpdating) {
                this.isUpdating = true
                this.applyChangesToYjs(changes)
                this.isUpdating = false
            }
        })
    }
}
```

## 既存プラグインと参考プロジェクト

### 商用成功例

**Peerdraft**は商業的に成功した協同編集プラグインです：
- ハイブリッドP2P+サーバー永続化
- エンドツーエンド暗号化
- Web エディター対応
- $30/年の価格設定で持続可能な収益モデル

### オープンソース参考実装

**brush701/obsidian-multiplayer**は技術的実証として優れており：
- WebRTC + Y.js の実装パターン
- AES-GCM暗号化
- SharedFolder概念の実装
- プレアルファ段階だが、基本アーキテクチャは参考になる

**Conclave**は包括的な技術ケーススタディを提供：
- カスタムCRDT実装の詳細な解説
- パフォーマンス最適化の具体例
- 10万操作で14秒→1秒未満への改善手法

## 実装ロードマップ

### Phase 1: MVP実装（週1-2）
```typescript
// 最小実装例
import * as Y from 'yjs'
import { WebrtcProvider } from 'y-webrtc'

export default class CollaborativePlugin extends Plugin {
    private ydoc: Y.Doc
    private provider: WebrtcProvider
    
    async onload() {
        this.ydoc = new Y.Doc()
        this.provider = new WebrtcProvider('room-name', this.ydoc)
        
        const ytext = this.ydoc.getText('content')
        // 基本的なエディター統合
    }
}
```
**目標**: 基本的なP2P協同編集機能
**コスト**: $0-5/月

### Phase 2: プロダクション対応（週3-4）
- カスタムシグナリングサーバー（Railway/Render）
- ユーザー存在表示
- 文書永続化（Firebase無料枠）
- **コスト**: $10-20/月

### Phase 3: スケール最適化（月2）
- ハイブリッドルーティング
- 高度な圧縮とバッチ処理
- 使用量分析と最適化
- **コスト**: 実際の使用量に基づくスケーリング

## 結論と推奨事項

この包括的な調査により、**Y.js + WebRTC P2Pアプローチ**がObsidian協同編集プラグインにとって最適解であることが確証されました。この手法により**月額$5-20の低コストで、Google Docsレベルの機能**を実現できます。

**重要成功要因**:
1. **技術選択**: Y.jsの成熟したCRDTエコシステム活用
2. **コスト最適化**: P2P中心のハイブリッドアーキテクチャ
3. **セキュリティ**: クライアントサイド暗号化による ゼロノレッジ設計
4. **段階的実装**: MVPからプロダクション品質へのスムーズな移行

この実装戦略により、技術的に堅牢で経済的に持続可能な協同編集機能をObsidianエコシステムに提供することが可能です。